# Hyoshoppingmall
개인 프로젝트로 진행한 쇼핑몰 사이트입니다.

## 개발환경

* Window 10 64x
* Eclisp
* Spring 4
* java
* jsp
* Oracle
* tomcat 8.5

## 개발내용

Spring로 만들어진 쇼핑몰입니다.

관리자 계정과 일반사용자 계정으로 나뉘어져서 이용할 수 있도록 제작되었으며
관리자는 물건 관리와 배송 , 일반 사용자는 쇼핑과 후기를 남길 수 있습니다.
관리자 계정의 기능은 아래와 같습니다.

- 물건 등록 , 삭제 , 수정
- 물건 배송 상태 갱신

일반 사용자 계정의 기능은 아래와 같습니다

- 회원가입
- 물건 후기 등록
- 카트담기
- 주문하기/주문 목록 확인하기
- 물건명 검색/ 카테고리 검색
- 추천목록 보기(보고 있는 카테고리의 조회수 top3 리스트를 보여줍니다.)
- 최근에 올라온 후기글 보기

## 개발 시 어려웠던점

* 로그인 세션만료 문제

  세션이 만료 됐을때 로그인을 안한 상태라도 로그인을 해야 넘어갈 수 있는 화면으로 넘어가지는 오류가 발생
 
  처음에는 세션을 확인하여 로그인 되어있는 상태라면 UI 버튼을 변경해서 접속버튼의 링크를 바꾸어서 로그인창으로 보내려 했으나
  오랜시간이 지나서 세션이 만료된 경우에는  실시간 동작을 하는것이 아니라서 로그인 정보가 해제 되었음에도 로그인을  해야 사용할 수있는
  기능의 화면으로 넘어가는 문제가 발생.
  
   그래서 예전에 본 적이 있던  Interceptor 라는 개념을 떠올려서 해결하려고 시도했음.
   인터셉터에서 preHandle 을 사용했는데 이는 컨트롤러가 실행되기전에 작동하는 코드로서
   로직이 작동하기전에  가장먼저 세션에 로그인 정보가 있는지 확인을 하여 위과 같은 이슈를 해결할 수 있었다.

   만약 인터셉터를 이용하지않고 처리 했다면 로그인을 해야 이동할 수 있는 화면의 제약조건을 하나하나 다 처리해줘야 했을테지만
   인터셉터를 이용하여 컨트롤러가 실행하기전에 한번에 처리가 가능했다.
   
   

* 조회수 체크 DB 개선

  구현된 기능중 고객이 보고 있는 카테고리의 조회수 top3 의 물건을 출력해주는 기능이 있다.
  
  이 기능을 처음 구현할때 조회한 물건의 조회수를 체크해야하고
  고객이 보고 있는 카테고리에서 조회수가 가장 높은 3개의 물건을 가져오는 상황을 생각해야했다.
  그래서 먼저 물건을 클릭하면 물건의 모든 정보를 가지고 있는 tbl_goods 테이블에서 카운트를 증가시키고
  조회수 top 3를 뽑아올떄는 고객이 보고 있는 카테고리에 속한 모든 물건의 정보를 가져온 뒤 상위 3개를 출력했다.
  
  그러나 이렇게 관리하면 DB의 데이터를 관리하면 비효율적이라고 생각한 부분이 두가지가 있었는데 아래와 같다
  
  1. 아직 조회수가 올라가지 않은 물건은 체크를 하지 않아도 되지만 해당 카테고리에 속한 모든 물건을 가져와서 작동하기에 
     불필요한 체크를 하게된다.
  2. 조회수와 해당 물건 번호만 필요한데 그 외의 정보도 가져오게 된다.

  이 부분을 개선하고 싶었고 아래와 같은 방법으로 개선했다.
  
  물건번호와 조회수만 저장하는 tbl_objectCount 라는 테이블을 새로 만들고 아래와 같이
  조회수가 증가한적이 있는 물건인지 아무도 클릭하지 않은 물건인지 상황을 구분하여 처리했다.
  이렇게 조회수만 관리하는 테이블을 만들어서 처리를 하면 
  조회수가 오르지 않은 물건은 체크하지 않아서 불필요한 동작을 줄이게 된다.
  
  <pre>
  <code>
  		ObjectCount objectCount = service.objectCountSearch(gdsNum); //카운트 테이블에 물건이
 		등록되어 있는지 체크하는 service
		if(objectCount == null) {//기존에 없던 물건이라면
			ObjectCount objectCount2 = new ObjectCount();
			String cateCode1 = view.getCateCode();
			objectCount2.setCateCode1(cateCode1);
			objectCount2.setGdsNum(gdsNum);
			service.objectCountinit(objectCount2);//처음 조회수가 올라간 데이터를 DB에 넣는 과정

			}
		else { //기존에 있던 물건이라면
			service.objectCount(gdsNum);// 물건 넘버를 서비스로 위임하고 카운트 증가
		}
   </code>
   </pre>
    
    
    
    
## 개발 후 느낀점

전에 진행한 프로젝트에 비해서 기능이 많고 상대적으로 복잡한 프로젝트였다.
이번에는 Spring-boot가 아닌 Spring 을 선택해서 개발했다.
Spring-boot의 편리성은 좋았지만  embeded tomcat을 사용하여 서버 설치없이 작동하기 때문에  비교적 규모가 큰 서비스에서는 
불안정하다고 글을 읽은적도 있고 Spring-boot 와 Spring 이 개발과정에서 큰 차이점은 없지만 
개발환경 설정 같은 부분에서 Spring도 익숙해지고 싶어서 선택했고 많은 공부가 됐다.

.
DB 부분에서도 JPA 와 Mysql 이 아닌 Mybatis 와 Oracle 을 이용해서 만들었다.
JPA를 이용해서 개발할때도 편리하다고 생각했지만 Mybatis는 실제 쿼리문과 상당히 흡사하게 사용할 수 있다는게 매력적으로 다가왔고
동적쿼리를 쉽게 사용할 수 있다는 점 또한 편리했다.

프로젝트의 크기가 커지니 가장 체감이 되는건 DB 설계와 쿼리문의 효율적인 작성의 필요성이였다.
많은 데이터가 연관되어 작동하기 때문에 많은 고민이 필요했다. 개선 사항에서도 DB 개선이 있었는데
사실 이게 올바른 개선인지에 대해서는 대량에 데이터를 입력하여 테스트 하지 못했기에 확신 할 수 없지만
DB와 서비스의 효율적인 동작에 대해 고민해 본 뜻깊은 경험이라고 생각한다.







